\documentclass{jss}
\usepackage{amsmath,amssymb}
\usepackage{bm}
\usepackage{multirow}
\usepackage{dcolumn}
\usepackage{rotating}
\usepackage{natbib}
\newcommand{\citeasnoun}{\cite}

\newcommand{\alal}{\mbox{\boldmath$\alpha$}}
\newcommand{\bebe}{\mbox{\boldmath$\beta$}}
\newcommand{\dede}{\mbox{\boldmath$\delta$}}
\newcommand{\e}{\varepsilon}
\newcommand{\ff}{\mbox{\boldmath$f$}}
\newcommand{\gaga}{\mbox{\boldmath$\gamma$}}
\newcommand{\lala}{\mbox{\boldmath$\lambda$}}
\newcommand{\phph}{\mbox{\boldmath$\phi$}}
\newcommand{\thth}{\mbox{\boldmath$\theta$}}
\newcommand{\xx}{\mbox{\boldmath$x$}}
\newcommand{\XX}{\mbox{\boldmath$X$}}
\newcommand{\yy}{\mbox{\boldmath$y$}}
\newcommand{\eps}{\varepsilon}
\newcommand{\specialcell}[2][c]{%
  \begin{tabular}[#1]{@{}c@{}}#2\end{tabular}}

\DeclareMathOperator{\argmin}{argmin}

\author{Eric Ghysels \\University of North Carolina \And Virmantas Kvedaras\\Vilnius University \And Vaidotas
  Zemlys\\Vilnius University}
\Plainauthor{Eric Ghysels, Virmantas Kvedaras, Vaidotas Zemlys}

\title{Mixed Frequency Data Sampling Regression Models: the \proglang{R}
    Package \pkg{midasr}}
\Plaintitle{Mixed Frequency Data Sampling Regression Models: The R Package midasr}
\Shorttitle{R package \pkg{midasr}}

\Abstract{
Regression models involving data sampled at different frequencies are of general interest. In this document the \proglang{R} package \pkg{midasr} is described within a MIDAS regression framework  with functional constraints on parameters put forward in work by \citeasnoun{ghysels_etal_midas-02a}, \citeasnoun{ghysels_etal_midas-joe} and
\citeasnoun{andreou:rmm}.
}
\Keywords{MIDAS, specification test}
\Plainkeywords{MIDAS, specification test}
\Address{
Eric Ghysels\\
Department of Economics\\
University of North Carolina - Chapel Hill\\
Gardner Hall, CB 3305 Chapel Hill, NC 27599-3305\\
E-mail: \email{eghysels@unc.edu}\\
URL: \url{http://www.unc.edu/~eghysels/}\\  
\\
Virmantas Kvedaras\\
Department of Econometric Analysis\\
Faculty of Mathematics and Informatics\\
Vilnius University\\
Naugarduko g. 24, Vilnius, Lithuania\\
E-mail: \email{virmantas.kvedaras@mif.vu.lt}\\
URL:\url{http://mif.vu.lt/ututi/teacher/vk}\\
\\
Vaidotas Zemlys\\
Department of Econometric Analysis\\
Faculty of Mathematics and Informatics\\
Vilnius University\\
Naugarduko g. 24, Vilnius, Lithuania\\
E-mail: \email{vaidotas.zemlys@mif.vu.lt}\\
URL:\url{http://mif.vu.lt/~zemlys/}
}


%\Submitdate{2014-01-28}
%% need no \usepackage{Sweave.sty}
\begin{document}

\section{Introduction}

Regression models involving data sampled at different frequencies are of general interest. In this document we introduce a \proglang{R} package \pkg{midasr} for the regression modeling with the mixed frequency data based on a framework put forward in recent work by \citeasnoun{ghysels_etal_midas-02a}, \citeasnoun{ghysels_etal_midas-joe} and
\citeasnoun{andreou:rmm} using so called MIDAS, meaning Mi(xed) Da(ta) S(ampling), regressions.\footnote{\cite{ghysels:2013} also developed a package for \proglang{MATLAB} which deals with the estimation and information criteria-based specification of MIDAS regressions as well as forecasting and nowcasting of slow frequency series.} 

In a general framework of regressions with functional constraints on parameters, the \pkg{midasr} package not only provides similar functionality within a standard \proglang{R} framework of the model specification comparable to that available in the usual functions \code{lm} or \code{nls}, but also deals with an extended model specification analysis for MIDAS regressions.

Several recent surveys on the topic of MIDAS are worth mentioning at the outset. They are: \cite{andreou2011forecasting} who review more extensively some of the material summarized in this document, \cite{armesto2010forecasting} who provide a very simple introduction to MIDAS regressions and finally \cite{ghysels_valkanov_chap} who discuss volatility models and mixed data sampling.

Econometric analysis of MIDAS regressions appears in \cite{ghysels:mrf}, \cite{andreou:rmm}, \cite{bai:kalman},
\cite{kvedaras-regression}, \cite{rodriguez2010mixed}, \cite{wohlrabe2009forecasting}, among others.

MIDAS regression can also be viewed as a reduced form representation of the linear projection which emerges from a state space model approach - by reduced form we mean that the MIDAS regression does not require the specification of a full state space system of equations.
\cite{bai:kalman} show that in some cases the MIDAS regression is an exact representation of the Kalman filter, in other cases it involves approximation errors which are typically small. The Kalman filter, while clearly optimal as far as linear projections goes, has several disadvantages (1) it is more prone to specification errors as a full system of measurement and state equations is required and as a consequence (2) requires a lot more parameters, which in turn results in (3) computational complexities which often limit the scope of applications. In contrast, MIDAS regressions - combined with forecast combination schemes if large data sets are involved (see \cite{AGK_macro}) are computationally easy to implement and more
prone to specification errors.

The key feature of the package is its flexibility in terms of the model formulation and estimation, which allows for the:
\begin{itemize}
\item estimation of regression models with its parameters defined (restricted) by a certain functional constraint,
which can be selected from a standard list or can be customized using a standard \proglang{R} \code{function};
\item parsimonious aggregation-linked restrictions (as e.g., in \citealp{ghysels:2013}) as a special case;
\item estimation of MIDAS models with many variables and (numerous) different frequencies;
\item constrained, partially constrained, or unconstrained estimation of the model;
\item various mixtures of restrictions/weighting schemes and also lag orders as they can be specific to each series;
\item statistical testing for the adequacy of the model specification and the imposed functional constraint;
\item information criteria and testing-based selection of models;
\item forecasting and nowcasting functionality, including various forecast combinations.
\end{itemize}

Suppose $\{y_t, t\in \mathbb{Z}\}$ is a univariate process observed at low frequency. Lags of the process are denoted by $By_t$ = $y_{t-1},$ where $B$ is the low frequency lag operator. A MIDAS regression involves linear projections using stochastic processes $\{x_{\tau}^{(i)}, \tau \in \mathbb{Z}\},$
$i=0,\dots,h,$  observed at a higher frequency, i.e., for each low
frequency period $t=t_0$ we observe the process $x_\tau^{(i)}$ at $m_i\in
\mathbb{N}$ high frequency periods $\tau=(t_0-1)m_i+1,\dots,t_0m_i$. Throughout the article we represent $i$-th high frequency period $\tau$ in terms of low frequency period $t$ as
$\tau=(t-1)m_i+j,$ $j=1,\dots,m_i$. Note that this notation does not exclude the case $m_i=1$. In that case the high frequency process $x_{\tau}^{(i)}$ is observed at the same frequency as the low frequency process $y_t$. However we require that $m_i\ge
1,$ such that the process $y_t$ is observed at the lowest frequency. Lags of the processes $x_{\tau}^{(i)}$ are denoted by $Lx^{(i)}_{\tau}=x_{\tau-1},$ where $L$ is the high frequency lag operator, which operates on the lag irrespective of the frequency of the process.

The package deals with any specification of mixed-frequency
regression model which can be represented as
\begin{align}\label{l:eqintro}
    y_t-\alpha_1y_{t-1}-\dots-\alpha_py_{t-p}=\sum_{i=0}^{h}\sum_{j=0}^{k_i}\beta_{j}^{(i)}x_{tm_i-j}^{(i)}+\eps_t,
\end{align}
where we require
\begin{align*}
    E(\eps_t|y_{t-1},\dots,y_{t-p},x^{(0)}_{tm_0},\dots,x^{(0)}_{tm_0-k_i},\dots,x^{(h)}_{tm_h},\dots,x^{(h)}_{tm_h-k_h})=0,
\end{align*} so that the equation \eqref{l:eqintro} is identified as a projection equation.

The model stated in the equation \eqref{l:eqintro} can be estimated in the usual time series regression fashion or using a Bayesian approach. However, the number of parameters in this model $d$ = $p+\sum_{i=0}^hk_i$ can be very large in terms of the number $n$ of available observations of $y_t$\footnote{In the MIDAS literature it is common to have $k_i\ge m_i$ and $m_i$ can be large, for example monthly versus daily data}. Since the estimation of the model can
easily become infeasible, whenever either larger differences in frequencies or more variables and/or higher lag orders prevail, \cite{ghysels_etal_midas-02a} introduced a sufficiently flexible parametric restriction to be imposed on the original parameters,
\begin{align}\label{l:eqres}
    \beta_{j}^{(i)}=f_{i}(\gaga_i,j), \; j=0,\dots,k_i,\; \gaga_i=(\gamma_{1}^{(i)},\dots,\gamma_{q_i}^{(i)}), \; q_i\in\mathbb{N}.
\end{align}

This approach greatly reduces the number of parameters to be estimated, from $d$ to $q=\sum_{i=0}^{h_i}q_i,$ which is assumed to be always considerably less than the number of observations available at the lowest frequency. This gain is offset by the fact that \eqref{l:eqintro} becomes non-linear model, however if
the parameters of an underlying data generating process did follow a certain functional constraint which is perfectly or well approximated by a constraint function chosen by a researcher, then significant efficiency gains could be achieved from the imposed constraints. Figure \ref{fig:fig1} plots the out-of-sample prediction precision (left figure) and the parameter estimation precision (right figure) in an unconstrained and constrained simple model with correct and approximate restrictions (see Appendix A for details).

<<setup, include=FALSE, cache=FALSE>>=
render_sweave()
@

\begin{figure}[htbp]
 <<echo=FALSE,fig.show="hold",fig.height=3.5>>=
opts_chunk$set(tidy=TRUE,tidy.opts=list(keep.blank.line=FALSE, width.cutoff=60),highlight=FALSE,prompt=TRUE,comment=NA,background="#FFFFFF")
options(prompt="R> ")
suppressMessages(library("tseries"))
suppressMessages(library("midasr"))
suppressMessages(library("ggplot2"))
data("oos_prec")
qplot(x=n,y=value,data=oos_prec,geom="line",colour=Constraint,ylab="")+facet_wrap(~Type,scales="free_y")+xlab("Sample size")+theme_bw()
@
\caption{A plot depicting efficiency gains when the correct non-linear constraint is imposed. The left panel plots the average out-of-sample prediction accuracy against sample size. The right panel plots out the average euclidean distance of estimated model parameters to their true values.}
 \label{fig:fig1}
\end{figure}


As can be seen, even an incorrect constraint might be useful whenever the number of degrees of freedom in an unconstrained model is low and, consequently, one cannot rely on the large sample properties of unconstrained estimators. Furthermore, this approach seems to be necessary whenever estimation is simply infeasible because of the lack of degrees of freedom.

\section{Theory}\label{Theory}

The model \eqref{l:eqintro} can be rewritten in a more compact form:
\begin{equation}\label{eq1}
\alpha(B)y_{t}= \bebe(L)^\top\xx_{t,0}+\e_t,\\
\end{equation}
where $\alpha(z)=1-\sum_{j=1}^{p}\alpha_jz^j$ and
\begin{align*}
\xx_{t,0}:&=\left(x_{tm_0}^{(0)},\dots,x_{tm_i}^{(i)},\dots,x_{tm_h}^{(h)}\right)^\top,\\
\bebe(z)&= \sum_{j=0}^{k}\bebe_jz^j,\ \bebe_j=\left(\beta_j^{(0)},\dots,\beta_j^{(i)},\dots,\beta_j^{(h)}\right)^\top,\\
L^j\xx_{t,0}:&=\xx_{t,j}=\left(L^jx_{tm_0}^{(0)},\dots,L^jx_{tm_i}^{(i)},\dots,L^jx_{tm_h}^{(h)}\right)^\top.
\end{align*}
In order to simplify notation, without loss of generality, a single order of the lag polynomials is used with $k$ being the maximum lag order. If the orders of some components of $\bebe(z)$ are smaller, it is easy to set some coefficients of the polynomial equal to zero.

We require the existence of the continuous second derivative of  functional constraint with respect to its hyper-parameters i.e., $\frac{\partial^2 f_i}{\partial \gaga_i\partial \gaga_i^\top},$ but the function can be even discontinuous with respect to the lag index $j\in\mathbb{N}$ which allows for various non-smooth functions in terms of the lag index. The functional constraints can vary with each variable and/or frequency, and therefore we use $\gaga$ to represent a vector of all the parameters of a restricted model (unique hyper-parameters and parameters in $\alpha(z)$), with $q=\dim(\gaga)$ their total number.

As will be shown in the next section, all variants of the usual linear (in terms of variables) MIDAS regression model are covered by regression \eqref{eq1} via the specification of functional constraints. When each restriction function is an identity mapping, one obtain an unrestricted MIDAS regression model.\footnote{See \cite{foroni}.}

\subsection{Frequency alignment}


It is instructive to rewrite the model \eqref{l:eqintro} in a matrix notation. We start with a few examples. Suppose $y_t$ is observed quarterly and we want to explain its variation with the variable $x_\tau$, which is observed monthly. Since each quarter has three months, the frequency $m$ is 3 in this example. Suppose we assume that the monthly data in the current and the previous quarter has explanatory power. This means that for each quarter $t$ we want to model $y_t$ as a linear combination of variables $x_{3t},x_{3t-1},x_{3t-2}$ observed in the quarter $t$ and variables $y_{t-1}$ and $x_{3(t-1)},x_{3(t-1)-1},x_{3(t-1)-2}$ observed in the previous quarter $t-1$. In matrix notation the MIDAS model \eqref{l:eqintro} for this example is:
\begin{align*}
    \begin{bmatrix}
	y_2\\
	\vdots\\
	y_n
    \end{bmatrix}=
\begin{bmatrix}
	y_1\\
	\vdots\\
	y_{n-1}
    \end{bmatrix}\alpha_1+
\begin{bmatrix}
	x_6 & \dots &x_1\\
	\vdots & \vdots & \vdots\\
	x_{3n} & \dots & x_{3n-5}
    \end{bmatrix}
    \begin{bmatrix}
	\beta_0\\
	\vdots\\
	\beta_5
    \end{bmatrix}+
\begin{bmatrix}
	\eps_2\\
	\vdots\\
	\eps_n
    \end{bmatrix}
\end{align*}
By writing the model in the matrix notation we have transformed high-frequency variable $x_\tau$ into a low-frequency vector $(x_{3t},\dots,x_{3t-5})^\top$. We call this transformation the frequency alignment. Note that we require that the number of observations of $x_\tau$ is exactly $3n$.

Let us examine another example. Suppose we have another variable $z_t$ observed weekly which we want to add to the model. The model \eqref{l:eqintro} does not allow varying frequency ratios, so we need to assume that each month has exactly 4 weeks. If months do not always have four weeks, as they do in practice, one can simply think of this model as taking a fixed set of weekly lags.  The frequency $m$ for the variable $z_\tau$ is then 12. We use again the current and previous quarter data for explaining variation in $y_t$. This means that for quarter $t$ we model $y_t$ as a linear combination of variables $x_{3t},x_{3t-1},x_{3t-2}$ and $z_{12t},z_{12t-1},\dots,z_{12t-11}$ observed in the quarter $t$, and variables $y_{t-1}$, $x_{3(t-1)},\dots,x_{3(t-1)-2}$ and $z_{12(t-1)},z_{12(t-1)-1},\dots,z_{12(t-1)-11}$ observed in the quarter $t-1$. The model in the matrix form is then:
\begin{align*}
    \begin{bmatrix}
	y_2\\
	\vdots\\
	y_n
    \end{bmatrix}=
\begin{bmatrix}
	y_1\\
	\vdots\\
	y_{n-1}
    \end{bmatrix}\alpha_1+
\begin{bmatrix}
	x_6 & \dots &x_1\\
	\vdots & \vdots & \vdots\\
	x_{3n} & \dots & x_{3n-5}
    \end{bmatrix}
    \begin{bmatrix}
	\beta_0\\
	\vdots\\
	\beta_5
    \end{bmatrix}+
\begin{bmatrix}
        z_{24} & \dots &z_1\\
	\vdots & \vdots & \vdots\\
	z_{12n} & \dots & z_{12n-23}
    \end{bmatrix}
    \begin{bmatrix}
	\gamma_0\\
	\vdots\\
	\gamma_{23}
    \end{bmatrix}+
\begin{bmatrix}
	\eps_2\\
	\vdots\\
	\eps_n
    \end{bmatrix}
\end{align*}
In this example we have aligned $x_{\tau}$ into a vector $(x_{3t},..,x_{3t-5})^\top$ and $z_{\tau}$ into a vector $(z_{12t},\dots,z_{12t-23})^\top.$ Again we require that the number of observations of high frequency variables are multiple of $n$, with multiplication factor being the corresponding frequencies. This is not a restrictive assumption in practical applications as will be further explained in the section \ref{Implementation}.

Let us return to the general case of the model \eqref{l:eqintro}. We \textit{align the frequency} of high-frequency variable $x_\tau$ by transforming it to the low-frequency vector $(x_{tm_i}^{(i)},x_{tm_i-1}^{(i)},\dots,x_{tm_i-k}^{(i)})^\top$. The model $\eqref{l:eqintro}$ is then expressed in the matrix notation as follows:
\begin{align*}
    \begin{bmatrix}y_l\\\vdots\\y_n\end{bmatrix}=
	\begin{bmatrix}
	    y_{l-1} &\dots & y_{l-p}\\
	    \vdots & \vdots & \vdots\\
	    y_{n-1} & \dots & y_{n-p}
	\end{bmatrix}
	\begin{bmatrix}\alpha_1\\\vdots\\\alpha_p\end{bmatrix}+
	 \sum_{i=0}^h\XX^{(i)}\begin{bmatrix}\beta_0^{(i)}\\\vdots\\\beta_{k}^{(i)}\end{bmatrix}
	    +\begin{bmatrix}
		\eps_l\\\vdots\\\eps_n
	    \end{bmatrix},
\end{align*}
where
\begin{equation}\label{eq2}
\XX^{(i)}:=\left[
\begin{matrix}
x_{lm_i}^{(i)}&x_{lm_i-1}^{(i)}&\dots&x_{lm_i-k}^{(i)}\\
x_{(l+1)m_i}^{(i)}&x_{(l+1)m_i-1}^{(i)}&\dots&x_{(l+1)m_i-k}^{(i)}\\
\vdots&\vdots&\dots&\vdots\\
%\hline
x_{tm_i}^{(i)}&x_{tm_i-1}^{(i)}&\dots&x_{tm_i-k}^{(i)}\\
%\hline
\vdots&\vdots&\dots&\vdots\\
x_{(n-1)m_i}^{(i)}&x_{(n-1)m_i-1}^{(i)}&\dots&x_{(n-1)m_i-k}^{(i)}\\
x_{nm_i}^{(i)}&x_{nm_i-1}^{(i)}&\dots&x_{nm_i-k}^{(i)}\\
\end{matrix}\right],
\end{equation}
and $l$ is the smallest integer such that $lm_i-k>0$ and $l>p$.

The purpose of this subsection was to show how the frequency alignment procedure turns a MIDAS regression into a classical time series regression where all the variables are observed at the same frequency.

\subsection{Estimation}

Equation \eqref{eq1} can be estimated directly via ordinary least squares (OLS), without restrictions on the parameters. This is a so called U-MIDAS regression model, see \cite{foroni}. Furthermore, a consistent non-parametric approach could be used to estimate the underlying parameters of a function as e.g., in \cite{breitung:2013}. Since, none of these approaches use a parametric functional constraint, they can be estimated using already available \proglang{R} packages. The \pkg{midasr} package aims at the estimation of mixed frequency models with some parametric functional constraints.

While model \eqref{eq1} is a linear model in terms of variables, any non-linear functional constraints will result in non-linearities with respect to the hyper-parameters $\gaga.$ Therefore, in the general case, we use in the function \code{midas_r} the non-linear least squares (NLS) estimator of parameters $\gaga$ of a restricted model \eqref{eq1} as defined by
\begin{equation}\label{eqNLS}
\widehat \gaga=\underset{\gaga\in\mathbb{R}^q}{\argmin}\  \sum_{\lceil (k+1)/m\rceil}^{n}\bigg(\alpha(B)y_t- \ff_{\gaga}(L)^\top \xx_{t,0}\bigg)^2,
\end{equation}
where the lag polynomial of constrained parameters is defined by
$$
\ff_{\gaga}(z)=\sum_{j=0}^k\ff_{\gaga,j}z^j
$$
with
$$
\ff_{\gaga,j}=\bigg(f_{0}(\gaga_{0};j),\dots,f_{i}(\gaga_{i};j),\dots,f_{h}(\gaga_{h};j)\bigg)^\top
$$
for each $(i,j)\in\{0,1,\dots,h\}\times\{0,1,\dots,k\}.$
A number of numerical algorithms are readily available in \proglang{R}. By default, the \code{optim} optimization function is used with optional choices of optimization algorithms in it. However, a user can also choose within the function \code{midas_r} other procedures available in \proglang{R} such as \code{nls}, customizing the desired algorithm which is suitable for the problem at hand.

The efficiency of the estimator and consistency of the standard errors depend on whether the errors of the model are spherical. We leave the aspect of efficiency of estimation to be considered by a user, however the implementation of heteroscedasticity and autocorrelation (HAC) robust standard errors is an option available in the package \pkg{sandwich} (see \citealp{zeileis:2004}).

If all the functional relations $f_i(\cdot)$ were non-constraining identity mappings, then the NLS estimator would be equivalent to the ordinary least squares (OLS) problem in terms of the original parameters. For convenience, such a U-MIDAS version can be dealt with directly using a different function \code{midas_u} of the package (see an illustration in section \ref{Implementation}) or a standard \code{lm} function, provided the alignment of data frequencies is performed as discussed in the previous section.

\subsection{Taxonomy of aggregates-based MIDAS regression models}
Based on the parsimony of representation argument, the higher-frequency part of conditional expectation of MIDAS regressions is often formulated in terms of aggregates as follows
\begin{equation} \label{eq3}
\begin{aligned}
\bebe(L)^\top \xx_{t,0}&=\sum_{i=0}^h\sum_{j=0}^k \beta_j^{(i)}x_{tm_i-j}^{(i)}\\
&=\sum_{i=0}^h\sum_{r=0}^p \lambda_r^{(i)}\tilde x_{t-r}^{(i)},\\
\end{aligned}
\end{equation}
with some low-frequency number of lags $p\in\mathbb{N}$ and parameter-driven low-frequency aggregates
\begin{equation*} %\label{eq3}
\begin{aligned}
\tilde x_{t-r}^{(i)}&:=x_{t-r}^{(i)}(\dede_{i,r})=\sum_{s=1}^{m_i}w_{r}^{(i)}(\dede_{i,r};s)x_{(t-1-r)m_i+s}^{(i)}
\end{aligned}
\end{equation*}
which depend on a weighting (aggregating within a low-frequency period) function $w_{r}(\dede_{i,r};s)$ with its hyper-parameter vector $\dede_{i,r},$ which, in the general case, can vary with each variable/frequency and/or the low-frequency lag order $r\in\mathbb{N}.$ Here the aggregation weights are usually non-negative and, for identification of parameters $\{\lambda_r^{(i)}\}_{i=0,r=0}^{h,p},$ satisfy the normalization constraint such as  $\sum_{s=0}^{m_i-1}w_{r}(\dede_{i,r};s)=1.$ To have the weights add to one, it is convenient to define a weighting function in the following form
\begin{equation}\label{eq4}
\forall \ i,r\ \  w_{r}^{(i)}(\dede_{i,r};s)=\frac{\psi_{r}^{(i)}(\dede_{i,r};s)}{\sum_{j=1}^{m_i}\psi_{r}^{(i)}(\dede_{i,r};j)},\ s=1,\dots,m_i,
\end{equation}
given some underlying function $\psi_{r}^{(i)}(\cdot).$ Provided that the latter function is non-negatively-valued (and the denominator is positive), the resulting weights in eq. \eqref{eq4} are also non-negative. Table \ref{tab:1} provides a list of some  underlying functions producing, within the context of equation \eqref{eq4}, the usual weighting schemes with non-negative weights (whenever the parameter space of underlying functions is appropriately bounded, which in some cases is also needed for identification of hyper-parameters). In order to avoid heavy notation, indices $i$ and $r$---which are connected respectively with frequency/variable and the lag order---are dropped in the table. %Furthermore, a variable $x_s\in(0,1)$ is used as defined by $x_s:=\xi+(1-\xi)h(s),\ h(s):=(s-1)/({m}-1)$ for some marginally small quantity $\xi>0.$ %[??Keistoka, kad kai kur yra 1:d/d (nors tikriausiai visur keicia tik paramtro reiksme). Kam tokia dalyba, jei $x\in\mathbb{R}_+$; o jei norima normuoti ant $[0,1],$ kodel ne $x_s$??]

\begin{table}[htp]
\begin{center}
\small{
\begin{tabular}{lcc}
\hline\hline
\parbox[c]{4cm}{ {\bf Resulting (normalized) weighting scheme}}& {\bf $\psi(\dede;s):=\psi_{r}^{(i)}(\dede_{i,r};s)$} & {\bf Related midasr function}\\
%\shortstack{aa \\
\hline
\parbox[c]{4cm}{ Exponential Almon lag polynomial} &\parbox[c]{5.5cm}{ $\psi(\dede;s)=\exp\left(\sum_{j=1}^p\delta_{j}s^j\right),\ p\in\mathbb{N},$ \newline where $\dede=\left(\delta_{1},\dots,\delta_{j},\dots,\delta_{p}\right)^\top\in\mathbb{R}^p.$ }&\code{nealmon}\\
\hline
\parbox[c]{4cm}{Beta (analogue of probability density function)} &\parbox[c]{5.5cm}{ $\psi(\dede;s)=x_s^{\delta_{1}-1}(1-x_s)^{\delta_{2}-1},$ where \newline
$x_s:=\xi+(1-\xi)h(s),\ h(s):=(s-1)/({m}-1),$ with some marginally small quantity $\xi>0,$ and  $\dede=\left(\delta_{1},\delta_{2}\right)^\top\in\mathbb{R}_+^2$.}&\code{nbeta}\\
 \hline
\parbox[c]{4cm}{Gompertz (analogue of probability density function)} &\parbox[c]{5.5cm}{ $\psi(\dede;s)=z(s)e^{-\delta_1z(s)},$ where \newline  $z(s)=\exp\big(\delta_{2}s\big),$ and   $\dede=\left(\delta_{1},\delta_{2}\right)^\top\in\mathbb{R}_+^2$.}&\code{gompertzp}\\
 \hline
\parbox[c]{4cm}{Log-Cauchy (analogue of probability density function)} &\parbox[c]{5.5cm}{  $\psi(\dede;s)=s^{-1}\left(\delta_2^2+(\ln s-\delta_1)^2\right)^{-1},$ where \newline $\dede=\left(\delta_{1},\delta_{2}\right)^\top\in\mathbb{R}\times\mathbb{R}_+.$ }&\code{lcauchyp}\\
 \hline
\parbox[c]{4cm}{Nakagami (analogue of probability density function)} &\parbox[c]{5.5cm}{ $\psi(\dede;s)=s^{2\delta_1-1}\exp(-\delta_1/\delta_2 s^2),$ where \newline $\dede=\left(\delta_{1},\delta_{2}\right)^\top,$ $\delta_{1}\geq0.5, \delta_2\in\mathbb{R}_+$.}& \code{nakagamip}\\
% \hline
%\parbox[c]{4cm}{Polynomial step function weighting scheme} &\parbox[c]{7cm}{ $w_{\cdot,j}^{(i)}(\dede_{i,\cdot})=\frac{\exp\left(\sum_{s=1}^p\delta_{s,\cdot}^{(i)}j^s\right)}{\sum_{j=1}^{k_i}\exp\left(\sum_{s=1}^p\delta_{s,\cdot}^{(i)}j^s\right)},$ \newline where $\dede_{i,\cdot}=\left(\delta_{1,\cdot}^{(i)},\dots,\delta_{j,\cdot}^{(i)},\dots,\delta_{p_i,\cdot}^{(i)}\right)^\top.$ }&wpolystep()\\
\hline\hline
\end{tabular}
}
\caption{\label{tab:1} A sample of usual weighting schemes in aggregation-based MIDAS specifications.}
\end{center}
\end{table}

Some other weighting functions which do not have a representation as in eq. \eqref{eq4} are also available in the package  such as (non-normalized) \code{almonp} and the polynomial specification with step functions \code{polystep} (see \cite{ghysels:mrf} for further discussion of step functions).

%Since it is usual in the aggregate-based MIDAS to present models with a single mixed frequency and the same aggregation weighting scheme, without loss of generality we will adopt this convenience in this section for exposition clarity and simplicity of comparison.

However, the choice of a particular weighting function in the MIDAS regression with aggregates represents only one restriction imposed on $\bebe(L)$ out of many other choices to be made. To see this, let us note that aggregates-based MIDAS regressions can be connected with the following restrictions on the conditional expectation of model \eqref{eq1}:
\begin{equation}\label{eq5}
\begin{aligned}
E\left(\alpha(B)y_t|\yy_{t,1},\{\xx_{t,0}^{(i)}\}_{j=0}^{k}\right)
&=\bebe(L)^\top \xx_{t,0}\\
%&=\sum_{i=0}^h\sum_{j=0}^k \beta_j^{(i)}x_{tm_i-j}^{(i)}\\
&=\sum_{i=0}^h\sum_{r=0}^p \lambda_r^{(i)}\tilde x_{t-r}^{(i)},\\
&=\sum_{i=0}^h\sum_{r=0}^p \lambda_r^{(i)}\sum_{s=1}^{m_i}w_{r}^{(i)}(\dede_{i,r};s)x_{(t-1-r)m_i+s}^{(i)},\\
\bigg|_{w_{r}^{(i)}(\cdot)=w_{r}(\cdot)}&=\sum_{i=0}^h\sum_{r=0}^p \lambda_r^{(i)}\sum_{s=1}^{m_i}w_{r}(\dede_{i,r};s)x_{(t-1-r)m_i+s}^{(i)},\\
\bigg|_{w_{r}(\cdot)=w(\cdot)}&=\sum_{i=0}^h\sum_{r=0}^p \lambda_r^{(i)}\sum_{s=1}^{m_i}w(\dede_{i,r};s)x_{(t-1-r)m_i+s}^{(i)},\\
\bigg|_{\dede_{i,r}=\dede_i}&=\sum_{i=0}^h\sum_{r=0}^p \lambda_r^{(i)}\sum_{s=1}^{m_i}w(\dede_{i};s)x_{(t-1-r)m_i+s}^{(i)},\\
\bigg|_{\lambda_{r}^{(i)}=\lambda^{(i)}}&=\sum_{i=0}^h\lambda^{(i)}\sum_{r=0}^p \sum_{s=1}^{m_i}w(\dede_{i};s)x_{(t-1-r)m_i+s}^{(i)},\\
\end{aligned}
\end{equation}
where $\yy_{t,1}=(y_{t-1},...,y_{t-p})^\top$. 

As can be seen---and leaving aside other less intuitive restrictions---depending on the choice of a particular MIDAS specification with aggregates, it can impose restrictions on the equality of
\begin{itemize}
\item the applied weighting scheme/function across variables and/or frequencies ($\forall \ i,\ \ w_{r}^{(i)}(\cdot)=w_{r}(\cdot)$);
\item the applied weighting scheme/function across all low-frequency lags $r=0,1,\dots,p$ of aggregates ($\forall \ r,\ \ w_{r}(\cdot)=w(\cdot)$);
\item parameters of the weighting functions in each lag ($\forall \ r,\ \ \dede_{i,r}=\dede_{i}$);
\item impact of contemporaneous and lagged aggregates for all lags ($\forall \ r,\ \ \lambda_{r}^{(i)}=\lambda^{(i)}$).
\end{itemize}
Furthermore, let $s_i$ stand for an enumerator of $i^{th}$ higher-frequency periods within a low-frequency period. Then, noting that, given a frequency ratio $m_i,$ there is a one-to-one mapping between higher-frequency index $j\in\mathbb{N}$ and a pair $(r,s_i)\in\mathbb{N}\times\{1,2,\dots,m_i\}$
$$
j=rm_i+s_i,
$$
it holds
\begin{equation}\label{eq6}
f_i(\gaga_{i};rm_i+s_i)=\lambda_r^{(i)}w_r^{(i)}(\dede_{i,r};s).
\end{equation}
Hence, it is easy to see that the aggregates-based MIDAS induces a certain periodicity of the functional constraint $f_{i}$ in eq. \eqref{eq1} as illustrated bellow using a stylized case where all the restrictions are imposed in eq. \eqref{eq5}:

{\small
\begin{tabular}{llll|llll|l}
%$f_{i}(\cdot,0),$&$f_{i}(\cdot,1),$&$\dots$&$f_{i}(\cdot,m-1)$&$f_{i}(\cdot,m),$&$f_{i}(\cdot,m+1),$&$\dots$&$f_{i}(\cdot,2m-1)$&\dots \\
%$\lambda_0^{(i)}w_0^{(i)}(\cdot,1),$&$\lambda_0^{(i)}w_0^{(i)}(\cdot,2),$&\dots&$\lambda_0^{(i)}w_0^{(i)}(\cdot,m)$&$\lambda_1^{(i)}w_1^{(i)}(\cdot,1),$&$\lambda_1^{(i)}w_1^{(i)}(\cdot,2),$&\dots&$\lambda_1^{(i)}w_1^{(i)}(\cdot,m)$&\dots
$f_{i}(\cdot,0),$&$f_{i}(\cdot,1),$&$\dots$&$f_{i}(\cdot,m-1)$&$f_{i}(\cdot,m),$&$f_{i}(\cdot,m+1),$&$\dots$&$f_{i}(\cdot,2m-1)$&\dots \\
$\lambda^{(i)}w(\cdot,1),$&$\lambda^{(i)}w(\cdot,2),$&\dots&$\lambda^{(i)}w(\cdot,m)$&$\lambda^{(i)}w(\cdot,1),$&$\lambda^{(i)}w(\cdot,2),$&\dots&$\lambda^{(i)}w(\cdot,m)$&\dots
\end{tabular},\\
}
for any $i\in\{0,1,\dots,h\}.$
From eq. \eqref{eq6} it is clear that any specification of MIDAS regression models which relies on aggregates is a special case of representation \eqref{eq1} with just a specific functional constraint on parameters. On the other hand, not every general constraint $\bebe(L)$ can be represented using periodic aggregates. For instance, in the above characterized example the correspondence necessarily breaches whenever there exists at least one frequency $i,$ for which none of $p\in\mathbb{N}$ satisfies $k=pm_i-1.$

\subsection{Specification selection and adequacy testing}

Besides the usual considerations about the properties of the error term,  there are two main questions about the specification of the MIDAS regression models. First, suitable functional constraints need to be selected, since their choice will affect the precision of the model. 
Second, the appropriate maximum lag orders need to be chosen.

One way to address both issues together is to use some information criterion to select the best model in terms of the parameter restriction and the lag orders using either in- or out-of-sample precision measures. Functions \code{midas_r_ic_table} and \code{amidas\_table} of the package allow the user to make an in-sample choice using some usual information criteria, such as AIC and BIC, and a user-specified list of functional constraints.\footnote{Although aimed at forecasting, the function \code{select\_forecasts} can also be used to perform the selection of models relying on their out-of-sample performance.}

Another way is to test the adequacy of the chosen functional constraints. For instance, whenever the autoregressive terms in model \eqref{eq1} are present ($p>0$), it was pointed out by \cite{ghysels:mrf} that, in the general case, $\phph(L)=\bebe(L)/\alpha(B)$ will have seasonal pattern thus corresponding to some seasonal impact of explanatory variables on the dependent one in a pure distributed lag model (i.e., without autoregressive terms). To avoid such an effect whenever it is not (or is believed to be not) relevant, \cite{clements2008mfm} proposed to us a common factor restriction which can be formulated as a common polynomial restriction with a constraint on the polynomial $\bebe(L)$ to satisfy a factorization $\bebe(L)=\alpha(B)\phph(L),$ so that inverting equation \eqref{eq1} in terms of the polynomial $\alpha(B)$ leaves  $\phph(L)$ unaffected i.e., without creating/destroying any (possibly absent) seasonal pattern of the impact of explanatory variables.
  However, there is little if any knowledge a priori whether the impact in the distributed lag model should be seasonal or not. Hence, an explicit testing of adequacy of the model and, in particular, of the imposed functional constraint is obviously useful.

  Let $\bebe$ denote a vector of all coefficients of polynomial $\bebe(z)$ defined in eq. \eqref{eq1}, while $\ff_{\gaga}$ stand for the corresponding vector of coefficients restricted by a (possibly incorrect) functional constraint in $\ff_{\gaga}(z).$ Let $\bm{\widehat{\beta}}$  denote the respective OLS estimates of unconstrained model i.e., where functional restrictions of parameters are \textit{not} taken into account. Let $\bm{\hat{\ff}_{\gaga}}:=\ff_{\gaga}\big|_{\gaga=\widehat\gaga}$ denote a vector of the corresponding quantities obtained from the restricted model relying on the NLS estimates $\widehat{\gaga}$ as defined in eq. \eqref{eqNLS}. Denote by $\alal,\ \widehat\alal,$ and $\widehat\alal_{\gamma}$ the corresponding vectors of coefficients of polynomial $\alpha(z),$ its OLS estimates in an unrestricted model, and its NLS estimates in a restricted model.\footnote{Recall that unconstrained $\alal$ elements make a subset of parameter vector $\gaga$ of a constrained model.}
 Let $\thth:=(\alal^\top,\bebe^\top)^\top,$  $\widehat\thth:=(\widehat\alal^\top,\widehat\bebe^\top)^\top,$ and $\widetilde\thth:=(\widehat\alal_{\gaga}^\top,\hat\ff_{\gaga}^\top)^\top$  signify the corresponding vectors of all coefficients in eq. \eqref{eq1}.
Then,
under the null hypothesis of $\exists \ \gaga\in\mathbb{R}^q\text{ such that }\ff_{\gaga}=\bebe,$ it holds
\begin{align*}
  (\bm{\widehat{\thth}}-{\bm{\widetilde{\thth}}})^\top\bm{A}(\bm{\widehat{\thth}}-\bm{\widetilde{\thth}})\sim \chi^2\big(d-q\big),
\end{align*}
where $\bm{A}$ is a suitable normalization matrix (see \citealp{kvedaras:2012} for a standard and \citealp{kvedaras:2013} for a HAC-robust versions of the test), and $q=\dim(\gaga)$ and $d=\dim(\thth)$  stand for the number of parameters in a restricted and unrestricted models, respectively. Functions \code{hAh.test} and \code{hAhr.test} of the package implement the described testing as will be illustrated later.

\subsection{Forecasting}

Let us write model \eqref{eq1} for period $t+1$ as
\begin{equation}\label{eq8a}
y_{t+1}=\alal^\top\yy_{t,0}+\bebe(L)^\top\xx_{t+1,0}+\e_{t+1},
\end{equation}
where $\yy_{t,0}=(y_{t},\dots,y_{t-p+1})^\top$ and $\alal=(\alpha_{1},\alpha_{2},\dots,\alpha_{p})^\top$ is a vector of parameters of the autoregressive terms. This representation is well suited for (one step ahead) conditional forecasting of $y_{t+1},$ provided that the information on the explanatory variables is available. If it were absent, forecasts of $\xx_{t+1,0}$ would be also necessary from a joint process of $\{y_t,\xx_{t,0}\}$ which might be difficult to specify and estimate correctly, especially, bearing in mind the presence of data with mixed frequencies. Instead, a direct approach to forecasting is often applied in the MIDAS framework. Namely, given an information set available up to a moment $t$ defined by $\mathcal{I}_{t,0}=\{\yy_{t,j},\xx_{t,j}\}_{j=0}^{\infty},$ where 
\begin{align*}
 \yy_{t,j}&=(y_{t-j},...,y_{t-j-p+1})^\top\\
 \xx_{t,j}&=(x^{(0)}_{tm_0},...,x^{(i)}_{tm_i},...,x^{(h)}_{tm_h})^\top,
\end{align*}
an $\ell$-step ahead direct forecast
\begin{equation}\label{eq8}
\tilde y_{t+\ell}=E\left(y_{t+\ell}\big|\mathcal{I}_{t,0}\right)=\alal_\ell^\top\yy_{t,0}+\bebe_\ell(L)^\top\xx_{t,0},\ \ell\in\mathbb{N},
\end{equation}
can be formed leaning on a model linked to a corresponding conditional expectation
$$
y_{t+\ell}=\alal_\ell^\top\yy_{t,0}+\bebe_\ell(L)^\top\xx_{t,0}+\e_{\ell,t},\ E\left(\e_{\ell,t}\big|\mathcal{I}_{t,0}\right),
$$
where $\alal_\ell$ and $\bebe_\ell(L)$ are the respective horizon $\ell$-specific parameters. Note that, in principle, these conditional expectations have a form of representation \eqref{eq1} with certain restrictions on the original lag polynomials of coefficients. Hence, in the  general case,  the suitable restrictions for each $\ell$ will have a different form.

Given periods $\ell=1,2,\dots,$ and a selected model or a list of specifications to be considered, package \pkg{midasr} provides the point forecasts corresponding to the estimated analogue of eq. \eqref{eq8}  evaluates the precision of different specifications, and performs weighted forecasting using the framework defined in \cite{ghysels:2013}.


\section{Implementation in {midasr} package}\label{Implementation}
\subsection{Data handling}

From a data handling point of view, the key specificity of the MIDAS regression model is that the length of observations of variables observed at various frequencies differs and needs to be aligned as described in Section \ref{Theory}. There is no existing \proglang
{R} function which performs such a transformation and the package \pkg
{midasr} provides a solution to these challenges. The basic functionality of data handling is summarized in Table \ref{tab:2}.
%\begin{sidewaystable}[p]
\begin{table}[htp]
\begin{center}
\small{
\begin{tabular}{llll}
\hline\hline
{\bf Function}& {\bf Description}& {\bf Example}&{\bf Notes}\\
%\shortstack{aa \\
\hline
\code{mls(x, k, m)} & \parbox[c]{4cm}{Stacks a HF data vector $x$ into a corresponding matrix of observations at LF of size  $\frac{\dim{x}}{m}\times\dim{k}$: from the first to the last HF lag defined by vector $k.$ }
 &\code{mls(x, 2:3, 3)}  & \parbox[c]{4cm}{$\frac{\dim{x}}{m}$ must be an integer (NA are allowed).  \newline For $m=1,$ the function produces lags of $x$ that are defined by vector argument $k,$ e.g., \code{mls(x, 2:3, 1)} yields a dataset containing the lags $x_{t-2}$ and $x_{t-3}$ of $x_t.$ }\\ 
\hline
\code{fmls(x, k, m)}&\parbox[c]{4cm}{Same as \code{mls}, except that $k$ is a scalar and the $k+1$ lags are produced starting from $0$ up to $k$.} & \code{fmls(x, 2, 3)} & \parbox[c]{4cm}{\code{fmls(x, 2, 3)} is equivalent to \code{mls(x, 0:2, 3)}.}
\\
\hline
\code{dmls(x, k, m)}&\parbox[c]{4cm}{Same as \code{fmls}, only the resulting matrix contains $k+1$ first-order HF differences of $x$.}&\code{dmls(x, 2, 3)}&\parbox[c]{4cm} {\code{mls(x, 1, 1)} can be used in \code{dmls} to get stacking of lagged differences, e.g., \code{dmls(mls(x, 1, 1), 2, 3)}.}\\
\hline\hline
\end{tabular}
}
\caption{A summary of a basic data handling functionality in the package \pkg{midasr}.}
\label{tab:2}
\end{center}
\end{table}
%\end{sidewaystable}

Function \code{fmls(x,k,m)} performs exactly the transformation defined in equation \eqref{eq2}, converting an observation vector $x$ of a given (potentially) higher-frequency series into the corresponding stacked matrix of observations of ($k+1$) low-frequency series (contemporaneous with $k$ lags) as defined by the maximum lag order $k$ and the frequency ratio $m.$ For instance, given a series of twelve observations

<<echo=TRUE, cache=TRUE, results="markup">>=
x<-1:12
@ 
we get the following result
<<echo=TRUE, cache=TRUE, results="markup">>=
fmls(x,k=2,m=3)
@ 
i.e., three variables (a contemporaneous and two lags) with four low-frequency observations ($n=12/m$).

Function \code{mls} is slightly more flexible as the lags included can start from a given order rather than from zero, whereas the function \code{fmls} uses a full lag structure. \code{dmls} performs in addition a first-order differencing of the data which is convenient when working with integrated series.

A couple of issues should be taken into account when working with series of different frequencies.
\begin{itemize}
\item It is assumed that the numbers of observations of different frequencies match exactly through the frequency ratio ($n_i=nm_i$), and the first and last observations of each series of different frequency are correspondingly aligned (possibly using \code{NA} to account for some missing observations for series of higher frequency).
\item Because of different lengths of series of various frequencies, the data in the model cannot be kept in one \code{data.frame}. An \proglang{R} object \code{list} needs to bee used if one intends to keep the data in a single object, but it is not required for the further modeling.
\end{itemize}

\subsection{An example of simulated MIDAS regression}\label{DGP}
Using the above data handling functions, it is straightforward to simulate a response series from the MIDAS regression as a data generating process (DGP). For instance, suppose one is willing to generate a low-frequency response variable $y$ in the MIDAS with two higher-frequency series $x$ and $z$ where the impact parameters satisfy the exponential Almon lag polynomials of different orders as follows:
\begin{equation}\label{eq9}
\begin{aligned}
y_t&=2+0.1t+\sum_{j=0}^7\beta_j^{(1)}x_{4t-j}+\sum_{j=0}^{16}\beta_j^{(2)}z_{12t-j}+\e_t,\\ %\ \e_t\sim n.i.d.(0,1)\\
x_{\tau_1}&\sim n.i.d.(0,1), \ \ z_{\tau_2}\sim n.i.d.(0,1), \ \ \e_t\sim n.i.d.(0,1),\\
\end{aligned}
\end{equation}
where $(x_{\tau_1},z_{\tau_2},\e_t)$ are independent for any  $({\tau_1},{\tau_2},t)\in\mathbb{Z}^3,$ and
$$
\beta_j^{(i)}=\gamma_0^{(i)}\frac{\exp\left(\sum_{s=1}^{q_i-1}\gamma_{s}^{(i)}j^s\right)}{\sum_{j=0}^{d_i-1}\exp\left(\sum_{s=1}^{q_i-1}\gamma_{s}^{(i)}j^s\right)},\ i=1,2,
$$
where $d_1=k_1+1=8$ is a multiple of the frequency ratio $m_1=4,$ whereas $d_2=k_2+1=17$ is not a multiple of $m_2=12.$ Here $q_1=2,$ $q_2=3$ with parameterizations
$$
\begin{aligned}
\gaga_1&=(1,-0.5)^\top,\\
\gaga_2&=(2,0.5,-0.1)^\top,\\
\end{aligned}
$$
which yield the shapes of functional constraints as plotted in Figure \ref{fig:fig2}.

\begin{figure}[t]
<<echo=FALSE,fig.show="hold",fig.height=3.5>>=
plot(x=0:16,nealmon(p=c(2,0.5,-0.1),d=17),type="l",xlab="High frequency lag",ylab="Weights",col=4)
lines(x=0:7,nealmon(p=c(1,-0.5),d=8),col=2)
@ 
\caption{A plot of shapes of functional constraints of $x_\tau$ (blue) and $z_\tau$ (red).}
\label{fig:fig2}
\end{figure}

The following \proglang{R} code produces a series according to the DGP characterized above:
<<echo=TRUE,cache=TRUE, results="markup">>=
set.seed(1001)
n<-250
trend<-c(1:n)
x<-rnorm(4*n)
z<-rnorm(12*n)
fn.x <- nealmon(p=c(1,-0.5),d=8)
fn.z <- nealmon(p=c(2,0.5,-0.1),d=17)
y<-2+0.1*trend+mls(x,0:7,4)%*%fn.x+mls(z,0:16,12)%*%fn.z+rnorm(n)
@ 
It is of interest to note that the impact of variable $x$ can be represented using aggregates-based MIDAS, whereas the impact of $z$ cannot.

\subsection{Some specification examples of MIDAS regressions}
Suppose now that we have (only) observations of $y,$ $x,$ and $z$ which are stored as vectors, matrices, time series, or list objects in \proglang{R}, and our intention is to estimate a MIDAS regression model as in equation \eqref{eq9}:
\begin{itemize}
\item[a)] without restricting the parameters (as in U-MIDAS) and using the OLS;
\item[b)] with the exponential Almon lag polynomial constraint on parameters (as in the function \code{nealmon}) and using the NLS.
\end{itemize}

The OLS estimation as in case a) is straightforwardly performed using

<<echo=TRUE,cache=TRUE, results="hide">>=
eq.u<-lm(y~trend+mls(x,k=0:7,m=4)+mls(z,k=0:16,m=12))
@ 
or, equivalently
<<echo=TRUE,cache=TRUE, results="hide">>=
eq.u<-midas_r(y~trend+mls(x,0:7,4)+mls(z,0:16,12),start=NULL)
@ 

The following \proglang{R} code estimates the constrained case b) using the function \code{midas_r} and reports the NLS estimates $\widehat{\gaga}$ of hyper-parameters with the related summary statistics.
<<echo=TRUE,cache=TRUE, results="markup">>=
eq.r<-midas_r(y~trend+mls(x,0:7,4,nealmon)+mls(z,0:16,12,nealmon),start=list(x=c(1,-0.5),z=c(2,0.5,-0.1)))
summary(eq.r)
@ 

As you can see the syntax of the function \code{midas_r} is similar to the standard \proglang{R} function \code{nls}. The model is specified via familiar \code{formula} interface. The lags included and functional restriction used can be individual to each variable and are specified within the respective \code{mls}, \code{fmls}, or \code{dmls} function used with \code{midas_r}. It is necessary to provide a list of starting values for each variable with restricted coefficients, since it implicitly defines the number of hyper-parameters of the constraint functions to be used for each series.

The main difference with the function \code{nls} is that there is a greater choice of numerical optimization algorithms. The function \code{midas_r} is written in a way that in theory it can use any \proglang{R} optimization function. The choice is controlled via \code{Ofunction} argument. Currently it is possible to use functions \code{optim} and \code{nls} which are present in a standard \proglang{R} installation and function \code{optimx} from the package \pkg{optimx} \cite{optimx}. The additional arguments to the aforementioned functions can be specified directly in the call to \code{midas_r}. So for example if we want to use the optimization algorithm of Nelder and Mead, which is the default option in the function \code{optim} we use the following code
<<eval=FALSE,echo=TRUE,cache=TRUE, results="markup", tidy=FALSE>>=
eq.r2 <- midas_r(y ~ trend + mls(x, 0:7, 4, nealmon) + 
                 mls(z, 0:16, 12, nealmon),
                 start = list(x = c(1, -0.5), z = c(2, 0.5, -0.1)),
                 Ofunction = "optim", method = "Nelder-Mead")
@ 
If we want to use  Golub-Pereyra algorithm for partially linear least-squares models implemented in the  function \code{nls} we use the following code
<<eval=FALSE,echo=TRUE,cache=TRUE, results="markup",tidy=FALSE>>=
eq.r2 <- midas_r(y ~ trend + mls(x, 0:7, 4, nealmon) + 
                 mls(z, 0:16, 12, nealmon),
                 start = list(x = c(1,-0.5), z = c(2, 0.5, -0.1)),              
                 Ofunction = "nls", method = "plinear")
@ 
It is possible to re-estimate the NLS problem with the different algorithm using as starting values the final solution of the previous algorithm. For example it is known, that the default algorithm in \code{nls} is sensitive to starting values. So first we can use the standard Nelder-Mead algorithm to find ``more feasible'' starting values and then use the \code{nls} to get the final result:
<<eval=FALSE,echo=TRUE,cache=TRUE, results="markup",tidy=FALSE>>=
eq.r2 <- midas_r(y ~ trend + mls(x, 0:7, 4, nealmon) + 
                 mls(z, 0:16, 12, nealmon),
                 start = list(x = c(1, -0.5), z = c(2, 0.5, -0.1)),
                 Ofunction = "optim", method = "Nelder-Mead")
eq.r2 <- midas_r(eq.r2, Ofunction = "nls")
@ 

The output of the optimization function used can be found by inspecting the element \code{opt} of \code{midas_r} output.
<<eval=TRUE,echo=TRUE,cache=TRUE, results="markup", tidy=FALSE>>=
eq.r2 <- midas_r(y ~ trend + mls(x, 0:7, 4, nealmon) + 
                 mls(z, 0:16, 12, nealmon),
                 start = list(x = c(1, -0.5), z = c(2, 0.5, -0.1)),
                 Ofunction = "optim", method = "Nelder-Mead")
eq.r2$opt
@ 
Here we observe that the Nelder-Mead algorithm evaluated the cost function 502 times.

The optimization functions in \proglang{R} report the status of the convergence of optimization algorithm by the numeric constant, 0 indicating succesful convergence. This code is reported as the element \code{convergence} of the \code{midas_r} output.
<<eval=TRUE,echo=TRUE,cache=TRUE, results="markup", tidy=FALSE>>=
eq.r2$convergence
@ 
In this case the convergence was not successfull. The help page of the function \code{optim} indicates that convergence code 1 means that the iteration limit was reached.

In order to improve the convergence it is possible to use user defined gradient functions. To use them it is necessary to define gradient function of the restriction. For example for the \code{nealmon} restriction the gradient function is defined in the following way:
<<eval=TRUE,echo=TRUE,cache=TRUE,resuls="markup",tidy=FALSE>>=
nealmon.gradient <- function(p, d, m) {
    i <- 1:d
    pl <- poly(i, degree = length(p) - 1, raw = TRUE)
    eplc <- exp(pl %*% p[-1])[, , drop=TRUE]
    ds <- apply(pl * eplc, 2, sum)
    s <- sum(eplc)
    cbind(eplc/s, p[1] * (pl * eplc/s - eplc %*% t(ds)/s^2))
}
@ 
The gradient functions are passed as named list elements via argument \code{weight_gradients} :
<<eval=TRUE,echo=TRUE,cache=TRUE,results="markup",tidy=FALSE>>=
eq.r2 <- midas_r(y ~ trend + mls(x, 0:7, 4, nealmon) + 
                 mls(z, 0:16, 12, nealmon),
                 start = list(x = c(1, -0.5), z = c(2, 0.5, -0.1)),
                 weight_gradients=list(nealmon = nealmon.gradient))
@ 
This way \code{midas_r} calculates the exact gradient of the NLS problem ~\eqref{eqNLS} using the specified gradient function of the restriction. For all the types of the restrictions referenced in table \ref{tab:3} their gradient functions are specified in the package \pkg{midasr}. The naming convention for gradient functions is \code{restriction_name.gradient}. It is not necessary to explicitly pass gradient functions named according to this convention. If \code{weight_gradients} is not \code{NULL} and does not contain apropriately named element, it is assumed that there exists gradient function conforming to gradient naming convention and it is then used.

The gradient and the hessian of the NLS problem are supplied as the output of \code{midas_r}. The numerical approximation of the hessian is calculated using the package \pkg{numDeriv} \cite{numderiv}, the exact gradient is calculated if \code{user.gradient=TRUE} and the numerical approximation otherwise. Having the gradient and hessian calculated allows to check whether the necessary and sufficient conditions for the convergence are satisfied. This is performed by the function \code{deriv_test} which calculates the Euclidean norm of the gradient and the eigenvalues of the hessian. It then tests whether the norm of gradient is close to zero and whether the eigenvalues are positive.


<<echo=TRUE,cache=TRUE, results="markup">>=
deriv_tests(eq.r, tol = 1e-06)
@ 
s
To retrieve a vector of constrained estimates  $\tilde\theta$ (and, hence, also $\hat\ff=\ff_{\gaga}\big|_{{\gaga}=\widehat{\gaga}}$) which.min corresponds to the vector ${\thth}$ ({\bebe}, respectively), the function \code{coef} can be used as follows
<<echo=TRUE,cache=TRUE, results="markup">>=
coef(eq.r, midas = TRUE)
@ 

In the example provided above, a functional constraint was imposed directly on  $\bebe(L)$ terms corresponding to each series without the usage of aggregates. Relying on the relationship \eqref{eq6}, it is always possible to write such an explicit general constraint from an aggregates-based one. For convenience of a user, the function \code{amweights} can be used to form several standard periodic functional constraints with 'typical'  restrictions explicated in equation \eqref{eq4}. For instance,

<<echo=TRUE,cache=TRUE, results="markup">>=
amweights(p=c(1,-0.5),d=8,m=4,weight=nealmon,type="C")
@ 
with \code{type="C"} corresponds to a fully restricted version of aggregates-based expression \eqref{eq4} apart the cross-restriction on the equality of weighting schemes between different variables/frequencies. Note that the code above repeats the result of
<<echo=TRUE,cache=TRUE, results="markup">>=
nealmon(p=c(1,-0.5),d=4)
@ 
twice ($d/m=2$), as implied by the number of periods at higher-frequency (\code{d=8}) and the frequency ratio (\code{m=4}). In this way, the function \code{amweights} can be used to define explicitly a new functional constraint relying on the relationship \eqref{eq6}. Alternatively, one can indicate directly within the function \code{midas_r} that the aggregates-based restriction must be used as follows
<<echo=TRUE,cache=TRUE, results="hide">>=
eq.r2<-midas_r(y~trend+mls(x,0:7,4,amweights,nealmon,"C")+mls(z,0:16,12,nealmon),start=list(x=c(1,-0.5),z=c(2,0.5,-0.1)))
@ 
where the first variable follows and aggregates-based MIDAS restriction scheme. Note that the selection of alternative types "A" and "B" are connected with specifications having a larger number of parameters (see Table \ref{tab:3}), hence the list of starting values needs to be adjusted to account for an increase in the number of (potentially unequal) impact parameters. %To simplify the usage, the starting values of a single period are used for all the lags. %[?? O kodel tas pats nepadaryta ir su poveikio parametrais? Manau, reikia naudoti vienodus ir cia??]

It should be also noted that, whenever the aggregates-connected restrictions are used, the number of periods must be a multiple of the frequency ratio. For instance, the current lag specification for variable $z$ is not consistent with this requirement and cannot be represented through the (periodic) aggregates, but either  \code{mls(z,0:11,12,amweights,nealmon,"C")} or \code{mls(z,0:23,12,amweights,nealmon,"C")} would be valid expressions from the code implementation point of view.

Table \ref{tab:3} summarizes and provides various other examples of correspondence between \code{midas_r} coding and the analytical specifications of MIDAS regressions.
\begin{sidewaystable}[p]
%\begin{table}[htp]
\begin{center}
\small{
\begin{tabular}{llll}
\hline\hline
{\bf Description}& {\bf Code example}& {\bf Analytical expression}&{\bf Notes}\\
%\shortstack{aa \\ 
\hline
\parbox[c]{3cm}{Different constraint functions}
&\parbox{7.3cm}{\code{midas\_r(y \~{} mls(x, 0:7, 4, nealmon) + \newline mls(z, 0:16, 12, gompertzp), start = list(x = c(1, -0.5), z = c(1, 0.5, 0.1)))} } 
&\parbox[c]{6cm}{$y_t=c+\sum_{j=0}^7\beta_j^{(1)}x_{4t-j}+\newline \sum_{j=0}^{16}\beta_j^{(2)}z_{12t-j}+\e_t$}& \parbox[c]{4.5cm}{Constraints on $\beta_j^{(i)},\ i=1,2$ are given by different functions.}\\
\hline
\parbox[c]{3cm}{Partial constraint\newline (only on $z$)}
&\parbox{6cm}{\code{midas\_r(y \~{} mls(x, 0:7, 4) + mls(z, 0:16, 12, nealmon), start = list(z = c(1, -0.5)))} } 
&\parbox[c]{6cm}{$y_t=c+\sum_{j=0}^7\beta_j^{(1)}x_{4t-j}+\newline \sum_{j=0}^{16}\beta_j^{(2)}z_{12t-j}+\e_t$}& \parbox[c]{4.5cm}{$x$ enters linearly with unconstrained $\beta_j^{(1)}$.}\\
\hline
\parbox[c]{3cm}{With unrestricted autoregressive terms}
&\parbox{6cm}{\code{midas\_r(y \~{} mls(y, 1:2, 1) + mls(x, 0:7, 4, nealmon), start = list(x = c(1, -0.5)))} } 
&\parbox[c]{6cm}{$y_t=c+\sum_{j=1}^{2}\alpha_jy_{t-j}+\newline \sum_{j=0}^7\beta_jx_{4t-j}+\e_t$}& \parbox[c]{4.5cm}{Autoregressive terms enter linearly with unconstrained coefficients.}\\
\hline
\parbox[c]{3cm}{With a common factor restriction}
&\parbox{6cm}{\code{midas\_r(y \~{} mls(y, 1:2, 1, "*") + mls(x, 0:7, 4, nealmon), start = list(x = c(1, -0.5)))} } 
&\parbox[c]{6cm}{$\alpha(B)y_t=c+\alpha(B)\lambda(L) x_{4t}+\e_t,$}& \parbox[c]{4.5cm}{Here coefficients of $\lambda(z)$ are assumed to satisfy nealmon restriction.}\\
\hline
\parbox[c]{3cm}{With autoregressive parameters restricted by a function}
&\parbox{6cm}{\code{midas\_r(y \~{} mls(y, 1:6, 1, nealmon) + mls(x, 0:7, 4, nealmon), start = list(y = c(1, -0.5), x = c(1, -0.5)))} } 
&\parbox[c]{6cm}{$y_t=c+\sum_{j=1}^{6}\alpha_jy_{t-j}+\newline \sum_{j=0}^7\beta_jx_{4t-j}+\e_t$}& \parbox[c]{4.5cm}{Autoregressive parameters $\alpha_j,\ j=1,\dots,6$ are constrained to satisfy nealmon restriction.}\\
\hline
\parbox[c]{3cm}{Aggregates-based \newline (Case A)}
&\parbox{6cm}{\code{midas\_r(y \~{} mls(x, 0:7, 4, amweights, nealmon, "A"), start = list(x = c(1, 1, 1, -0.5)))} } 
&\parbox[c]{6cm}{$y_t=c+\newline \sum_{r=0}^1\lambda_r\sum_{s=1}^{4}w(\dede_{r};s)x_{4(t-1-r)+s}+\e_t$}
& \parbox[c]{4.5cm}{The same weighting scheme (not parameters) is used in aggregation.}\\
\hline
\parbox[c]{3cm}{Aggregates-based \newline (Case B)}
&\parbox{6cm}{\code{midas\_r(y \~{} mls(x, 0:7, 4, amweights, nealmon, "B"), start = list(x = c(1, 1, -0.5)))} } 
&\parbox[c]{6cm}{$y_t=c+\newline \sum_{r=0}^1 \lambda_r\sum_{s=1}^{4}w(\dede;s)x_{4(t-1-r)+s}+\e_t$}
& \parbox[c]{4.5cm}{The same weights are used in aggregation.}\\
\hline
\parbox[c]{3cm}{Aggregates-based \newline (Case C)}
&\parbox{6cm}{\code{midas\_r(y \~{} mls(x, 0:7, 4, amweights, nealmon, "C"), start = list(x = c(1, -0.5)))} } 
&\parbox[c]{6cm}{$y_t=c+\newline \lambda\sum_{r=0}^1 \sum_{s=1}^{4}w(\dede;s)x_{4(t-1-r)+s}+\e_t$}
& \parbox[c]{4.5cm}{A common impact parameter of lags and the same weights are used in aggregation.}\\
\hline
\parbox[c]{3cm}{With a user-defined constraint}
&\parbox{6cm}{\code{midas\_r(y \~{} mls(x, 0:101, 4, fn), start = list(x = c(0, 0)))} } 
&\parbox[c]{6cm}{$y_t=c+\sum_{j=0}^{101}\beta_jx_{4t-j}+\e_t$, \newline  $\beta_j=\gamma_1(j+1)^{\gamma_2},\ j=0,1,\dots,101.$}& 
\parbox[c]{4.5cm}{User defined function: \code{fn <- function(p, d) p[1] * c(1:d)\^{}p[2]}.}\\
\hline\hline
\end{tabular}
}
\caption{A non-extensive list of possible specifications of the MIDAS regression in the \pkg{midasr} package.}
\label{tab:3}
\end{center}
%\end{table}
\end{sidewaystable}

\subsection{Adequacy testing of restrictions}
Given a MIDAS regression model estimated with \code{midas_r}, the empirical adequacy of the functional restrictions can be tested under quite standard assumptions (see \citealp{kvedaras:2012} and  \citealp{kvedaras:2013}) using  functions \code{hAh.test} and \code{hAhr.test} of the package. In the case of a stationary series $\{y_t\}$ they can be applied directly, whereas whenever $\{y_t\}$ is cointegrated with explanatory variables, a special transformation needs to be applied before the testing (see e.g., \citealp{bilinskas:2013}). The \code{hAh.test} can be used whenever errors of the process are independently and identically distributed, whereas the \code{hAhr.test} uses a HAC-robust version of the test. We should just point out that, whenever no significant HAC in the residuals  are observed, we would suggest using \code{hAh.test} which would then have more precise test sizes in small samples. In the case of integrated series $\{y_t\}$ which is co-integrated with explanatory variables, some other alternatives are available (see \citealp{kvedaras:2013b}).

For illustration, let us use the name \code{eq.r} of an estimated model as in the previous subsections. Then the functions produce, respectively,
<<echo=TRUE,cache=TRUE, results="markup">>=
hAh.test(eq.r)
hAhr.test(eq.r)
@
Here the value of a test statistic, the degrees of freedom (the number of binding constraints on parameters in equation \eqref{eq1}), and the empirical significance of the null hypothesis that a functional constraint is adequate are reported.

As can be seen, such a specification, which in fact corresponds to the underlying DGP, cannot be rejected at the usual significance levels, whereas e.g., reducing the number of hyper-parameters of functional constraint of variable $z$ to only two instead of three is quite strongly rejected using either version of the test:
<<echo=TRUE,cache=TRUE, results="markup",tidy=FALSE>>=
eq.rb <- midas_r(y ~ trend + mls(x, 0:7, 4, nealmon) + 
                 mls(z, 0:12, 12, nealmon),
                 start = list(x = c(1, -0.5), z = c(2, -0.1)))
hAh.test(eq.rb)
hAhr.test(eq.rb)
@ 

%[Perleidus MC empirinis reiksmingumas hAhr prie H0 neatrodo gerai lyginant su ant taip pat ivertinto modelio gautais hAh. Kazkur  sedi problema.] - viskas ok prie dideliu imciu, pvz., n=2000.

Whenever the empirical adequacy  cannot be reject at some appropriate level of significance for a couple of models, we could further rely on information criteria to make the selection of the best candidate(s).

\subsection{Model selection}
Suppose that we want to investigate which out of several functional constraints---for instance, the normalized ("nealmon") or non-normalized ("almonp") exponential Almon lag polynomials, or with polynomial of order 2 or 3, and so on---are better suited in a MIDAS regression model of $y$ on $x$ and $z$ (possibly different for each variable). Since the best maximum number of lags can differ with a functional constraint and/or variable/frequency, let us first define using the \pkg{midasr} function \code{expand_weights_lags} the sets of potential models corresponding to each explanatory variable  as follows % and the autoregressive terms of $y$ ;
<<echo=TRUE,cache=TRUE, results="markup",tidy=FALSE>>=
set.x <- expand_weights_lags(weights = c("nealmon", "almonp"),
                             from = 0, to = c(5, 10), m = 1,
                             start = list(nealmon = c(1, -1), 
                                          almonp = c(1, 0, 0)))
set.z <- expand_weights_lags(c("nealmon", "nealmon"),
                             0, c(10, 20), 1,
                             start = list(nealmon = c(1, -1), 
                                          nealmon = c(1, -1, 0)))
@ 
Here, for each variable, vector (or list) \code{weights} defines the potential restrictions to be considered and a list \code{start} gives the appropriate starting values defining implicitly the number of hyper-parameters per a function.

The potential lag structures are given by the following ranges of high-frequency lags: from [\code{from}; \code{m}$*\min$(\code{to})] to [\code{from}; \code{m}$*\max$(\code{to})]. When aggregates-based modeling is involved using \code{amweights} in \code{midas_r}, \code{m} can be set to the frequency ratio which ensures that the considered models (lag structures) are multiples of it. Otherwise, we would recommend to operate with high-frequency lag structures without changing the default value $m=1.$
Then, the set of potential models is defined as all possible different combinations of functions and lag structures with a corresponding set of starting values. A simple example bellow illustrates the result in order to reveal the underlying structure, which, besides the understanding of it, is otherwise not needed for a user.
<<echo=TRUE,cache=TRUE, results="markup",tidy=FALSE>>=
expand_weights_lags(weights = c("nealmon", "nbeta"),
                    from = 1, to = c(2, 3), m = 1,
                    start = list(nealmon = c(1, -1), 
                                 nbeta = rep(0.5, 3)))
@ 
Given the sets of potential specifications for each variable as defined above, the estimation of all the models is performed by

<<eval=FALSE,echo=TRUE,cache=TRUE, results="hide">>=
eqs.ic<-midas_r_ic_table(y~trend+mls(x,0,m=4)+fmls(z,0,m=12),table=list(z=set.z,x=set.x))
@ 
The function \code{midas_r_ic_table} returns
a summary table of all models together with the corresponding values of the usual information criteria and the empirical sizes of adequacy testing of functional restrictions of parameters. The result of derivative tests and the convergence status of the optimization function is also returned.

The summary table is a \code{data.frame} where each row corresponds to candidate model, so this table can be manipulated in the usual \proglang{R} way. The table can be accessed as \code{table} element of the list returned by \code{midas_r_ic_table}.  The list of fitted \code{midas_r} objects of all candidate models can be accessed as \code{candlist} element. It is possible to inspect each candidate model and fine-tune its convergence if necessary.

<<eval=FALSE,echo=TRUE,cache=TRUE,results="hide">>=
eqs.ic$candlist[[5]] <- midas_r(eqs.ic$candlist[[5]],Ofunction="nls")
@ 

The summary table can be recalculated by simply passing the fine-tuned list in to the function \code{midas_r_ic_table} again.
<<eval=FALSE,echo=TRUE,cache=TRUE,results="hide">>=
midas_r_ic_table(eqs.ic)
@ 
It should be pointed out that there is no need to provide the weighting function nor a specific lag order in the \code{mls} functions in such a case, since they are defined by the respective potential sets of models under option \code{table} in the function \code{midas_r_ic_table}. Any provided values with \code{mls} (or other similar functions) are over-written by those defined in \code{table}.

Finally, the best model in terms of a selected information criterion in a restricted or unrestricted model then is simply obtained by using
<<eval=FALSE,echo=TRUE,cache=TRUE, results="markup">>=
modsel(eqs.ic,IC="AIC",type="restricted")
@
which also prints the usual summary statistics as well as the testing of adequacy of the applied functional restriction using, by default, the \code{hAh.test}. A word of caution is needed here to remind that, as is typical, the empirical size of a test corresponding to a complex model-selection procedure might not correspond directly to a nominal one of a single-step estimation.

%For instance, whenever the data are generated by a DGP as was defined in subsection ???, and supposing that the lag orders where specified correctly (were known in advance) while it is only uncertain whether the normalized exponential Almon lag polynomial with two hyper-parameters or an unrestricted one with three hyper-parameters should be applied, we get the following result
%\begin{verbatim}
%\end{verbatim}
%which chooses the correct specification of the DGP. 

%???ghysels\_table???

\subsection{Forecasting}

Conditional forecasting (with confidence intervals, etc.) using unrestricted U-MIDAS regression models which are estimated using \code{lm} can be performed using standard \proglang{R} functions e.g.,  \code{predict.lm}. Conditional point prediction given a specific model is also possible relying on a standard \code{predict} function.

The function \code{predict} works similarly to \code{predict.lm}. It takes the new data, transforms it into an appropriate matrix and multiplies it with the coefficients. Suppose we want to produce the forecast $\hat{y}_{T+1|T}$  for the model \eqref{eq9}. To produce this forecast we need the data $x_{4(T+1)},...,x_{4T-3}
$ and $z_{12(T+1)},...,z_{12T-4}.$ It would be tedious to calculate precisely the required data each time we want to perform a forecasting exercise. To alleviate this problem the package \pkg{midasr} provides the function \code{forecast}. This function assumes that the model was estimated with the data up to low frequency index $T.$ It is then assumed that the new data is the data after the low frequency $T$ and then calculates the appropriate forecast. For example suppose that we have new data for one low frequency period for the model \eqref{eq9}. Here is how the forecast for one period would look like:

<<echo=TRUE,cache=TRUE,results="markup">>=
newx<-rnorm(4)
newz<-rnorm(12)
forecast(eq.rb,newdata=list(x=newx,z=newz,trend=251))
@ 

It is also common to estimate models which do not require new data for forecasting
\begin{align*}
y_{t+\ell}&=2+0.1t+\sum_{j=0}^7\beta_j^{(1)}x_{4t-j}+\sum_{j=0}^{16}\beta_j^{(2)}z_{12t-j}+\e_{t+\ell},
\end{align*}
where $\ell$ is the desired forecasting horizon. This model can be rewritten as
\begin{align*}
y_{t}&=2+0.1(t-\ell)+\sum_{j=4\ell}^{7+4\ell}\beta_j^{(1)}x_{4t-j}+\sum_{j=12\ell}^{16+12\ell}\beta_j^{(2)}z_{12t-j}+\e_t,
\end{align*}
and can be estimated using \code{midas_r}. For such a model we can get forecasts $\hat{y}_{T+\ell|T},...,\hat{y}_{T+1|T}$ using the explanatory variable data up to low frequency index $T.$ To obtain these forecasts using the function \code{forecast} we need to supply \code{NA} values for explanatory variables. An example for $\ell=1$ is as follows:
<<echo=TRUE,cache=TRUE,results="markup">>=
eq.f <- midas_r(y~trend+mls(x,4+0:7,4,nealmon)+mls(z,12+0:16,12,nealmon),
              start=list(x=c(1,-0.5),z=c(2,0.5,-0.1)))
forecast(eq.f,newdata=list(x=rep(NA,4),z=rep(NA,12),trend=251))
@ 
Note that we still need to specify a value for the trend.

In addition, the package \pkg{midasr} provides a general flexible environment for out-of-sample prediction, forecast combination, and evaluation of restricted MIDAS regression models using the function \code{select_and_forecast}. If exact models were known for different forecasting horizons, it can also be used just to report various in- and out-of-sample prediction characteristics of the models. In the general case, it also performs an automatic selection of the best models for each forecasting horizon from a set of potential specifications defined by all combinations of functional restrictions and lag orders to be considered, and produces forecast combinations according to a specified forecast weighting scheme.


In general, the definition of potential models in the function \code{select_and_forecast} is similar to that one uses in the model selection analysis described in the previous section. However, different best performing specifications are most likely related with each low-frequency forecasting horizon $\ell=0,1,2,\dots.$ Therefore the set of potential models (parameter restriction functions and lag orders) to be considered for each horizon needs to be defined.

Suppose that, as in the previous examples, we have variables $x$ and $z$ with frequency ratios $m_1=4$ and $m_2=12,$ respectively. Suppose that we intend to consider forecasting of $y$ up to three low-frequency periods $\ell\in\{1,2,3\}$ ahead. It should be noted that, in terms of high-frequency periods, they correspond to $\ell m_1\in\{4,8,12\}$ for variable $x,$ and $\ell m_2\in\{12,24,36\}$ for variable $z.$  Thus these variable-specific vectors define the lowest lags\footnote{Including lags smaller than that would imply that more information on explanatory variables is available and, in fact, $\ell-1$ forecasting horizon is actually under consideration.} of high-frequency period to be considered for each variable in the respective forecasting model (option \code{from} in the function \code{select_and_forecast}). Suppose further that in all the models we want to consider specifications having not less than 10 high-frequency lags and not more than 15 for each variable. This defines the maximum high-frequency lag of all potential models considered for each low-frequency horizon period $\ell\in\{1,2,3\}.$ Hence, for each variable, three corresponding pairs $(\ell m_1+10,\ell m_1+15),\ \ell\in\{1,2,3\}$ will define the upper bounds of ranges to be considered (option \code{to} in the function \code{select_and_forecast}).
For instance, for variable $x,$ three pairs $(14,19),(18,23),$ and $(22,27)$ correspond to $\ell=1,2,$ and $3$ and together with that defined in option \code{from} (see  \code{x=(4,8,12)}) imply that the following ranges of potential models will be under consideration for variable $x$:
\begin{itemize}
\item[$\ell=1:$]  \ \ from $[4-14]$ to $[4-19],$ \item[$\ell=2:$]  \ \ from $[8-18]$ to $[8-23],$ \item[$\ell=3:$]  \ \ from $[12-22]$ to $[12-27].$ \end{itemize}

The other options of the function \code{select_and_forecast} are options of functions \code{midas_r_ic_table}, \code{modsel} and \code{average_forecast}.

<<eval = FALSE, echo = TRUE, cache = TRUE, results = "hide", tidy = FALSE>>=
cbfc <- select_and_forecast(
           y ~ trend + mls(x, 0, 4) + mls(z, 0, 12),
           from = list(x = c(4, 8, 12), z = c(12, 24, 36)),
           to = list(x = rbind(c(14, 19), c(18, 23), c(22, 27)),
                     z = rbind(c(22, 27), c(34, 39), c(46, 51))),
           insample = 1:200, outsample = 201:250,
           weights = list(x = c("nealmon", "almonp"),
                          z = c("nealmon", "almonp")),
           wstart = list(nealmon = rep(1, 3), almonp = rep(1, 3)),
           IC = "AIC", seltype = "restricted", ftype = "fixed",                          
           measures = c("MSE", "MAPE", "MASE"),
           fweights = c("EW", "BICW", "MSFE", "DMSFE"))
@
The names of weighting schemes are taken from MIDAS \proglang{Matlab} toolbox \cite{ghysels:2013}. Similarly forecasting using rolling and recursive model estimation samples defined therein \cite{ghysels:2013} is supported by setting option \code{seltype = "rolling"} or \code{seltype = "recursive"}.

Then, among others,
<<eval=FALSE,echo=TRUE,cache=TRUE, results="markup">>=
cbfc$accuracy$individual
cbfc$accuracy$average
@
report, respectively:
\begin{itemize}
\item the best forecasting equations (in terms of a specified criterion out of the above-defined potential specifications), and their in- and out-of-sample forecasting precision measures for each forecasting horizon;
\item the out-of-sample precision of forecast combinations for each forecasting horizon.
%\item the best models for each forecasting horizon.	
\end{itemize}

The above example illustrated a general usage of the function \code{select_and_forecast} including selection of best models. Now suppose that a user is only interested in evaluating a one step ahead forecasting performance of a given model. Suppose further that he/she a priori knows that the best specifications to be used for this forecasting horizon $\ell=1$ is with
\begin{itemize}
\item \code{mls(x,4:12,4,nealmon)} with hyper-parameters \code{x=c(2,10,1,-0.1)} (the first one representing an impact parameter and the last three being the hyper-parameters of the normalized weighting function), and
\item \code{mls(z,12:20,12,nealmon)} with hyper-parameters \code{z=c(-1,2,-0.1)} i.e., with one hyper-parameter less in the weighting function.
\end{itemize}
Given already preselected and evaluated models, user can use the function \code{average_forecast} to evaluate the forecasting performance. To use this function at first it is necessary to fit the model and then pass it to function \code{average_forecast} specifying the in-sample and out-of-sample data, accuracy measures and weighting scheme in a similar manner to \code{select_and_forecast}
<<eval = FALSE, echo = TRUE, cache = TRUE, results = "markup", tidy = FALSE, label = avgf>>=
mod1 <- midas_r(y ~ trend + mls(x, 4:14, 4, nealmon) + 
                mls(z, 12:22, 12, nealmon),
                start = list(x = c(10, 1, -0.1), z = c(2, -0.1)))
avgf <- average_forecast(list(mod1),
                         data = list(y = y, x = x, z = z, trend = trend),
                         insample = 1:200, outsample = 201:250,
                         type = "fixed",                            
                         measures = c("MSE", "MAPE", "MASE"),
                         fweights = c("EW", "BICW", "MSFE", "DMSFE"))
@ 

It should also be pointed out that the forecast combinations in the function \code{select_and_forecast} are obtained only from the forecasts linked to different restriction functions on parameters. The forecasts related to different lag specifications are not combined, but the best lag order is chosen in terms of a given information criterion.
If there is a need to get forecast combinations for a group of models which the user selected using other criteria, the function \code{average_forecast} should be used in a manner outlined in the previous example.

\section{Empirical illustrations}

\subsection{Forecasting GDP growth}
We replicate the example provided in \cite{ghysels:2013}. In particular we run MIDAS regression to forecast quarterly GDP growth with monthly non-farms payroll employment growth. The forecasting equation is the following
\begin{align*}
y_{t+1} = \alpha+\rho y_{t}+\sum_{j = 0}^8\theta_jx_{3t-j}+\varepsilon_t,
\end{align*}
where $y_t$ is the log difference of quarterly seasonally adjusted real US GDP and $x_{3t}$ is the log difference of monthly total employment non-farms payroll. The data is taken from St. Louis FRED website.

First we load the data and perform necessary transformations.
<<echo = TRUE, cache = TRUE, results = "markup">>=
data("USqgdp")
data("USpayems")
y <- window(USqgdp, end = c(2011, 2))
x <- window(USpayems, end = c(2011, 7))

yg <- diff(log(y))*100
xg <- diff(log(x))*100

nx <- ts(c(NA, xg, NA, NA), start = start(x), frequency = 12)
ny <- ts(c(rep(NA, 33), yg, NA), start = start(x), frequency = 4)
@
The last two lines are needed to equalize the sample sizes, which are different in the original data. We simply add additional \code{NA} values at the beginning and the end of the data. The graphical representation of the data is shown in Figure \ref{fig:ghysels}.

\begin{figure}[tp]
  <<echo = FALSE, fig.show = "hold", fig.height = 4>>=
plot.ts(nx, xlab = "Time", ylab = "Percentages", col = 4, ylim = c(-5, 6))
lines(ny, col = 2)
@ 
\caption{A plot of time series of quaterly gross domestic product growth rates and monthly non-farm payroll employment growth rates.}
\label{fig:ghysels}
\end{figure}
To specify the model for the \code{midas_r} function we rewrite it in the following equivalent form:
\begin{align*}
y_t = \alpha+\rho y_{t-1}+\sum_{j = 3}^{11}\theta_jx_{3t-j}+\varepsilon_t,
\end{align*}
As in \cite{ghysels:2013} we restrict the estimation sample from the first quarter of 1985 to the first quarter of 2009.  We  evaluate the models with the Beta polynomial, Beta with non-zero and U-MIDAS weight specifications.
<<echo=TRUE,cache=TRUE,results="markup",label="gdp_define">>=
xx <- window(nx,start=c(1985,1),end=c(2009,3))
yy <- window(ny,start=c(1985,1),end=c(2009,1))

beta0 <- midas_r(yy~mls(yy,1,1)+mls(xx,3:11,3,nbeta),
                 start=list(xx=c(1.7,1,5)))

coef(beta0)

betan <- midas_r(yy~mls(yy,1,1)+mls(xx,3:11,3,nbetaMT),
                 start=list(xx=c(2,1,5,0)))
coef(betan)

um <- midas_r(yy~mls(yy,1,1)+mls(xx,3:11,3),start=NULL)
coef(um)

@ 
We can evaluate the forecasting performance of these three models on the out of sample data, containing 9 quarters, from 2009Q2 to 2011Q2

<<echo = TRUE, cache = TRUE, results = "markup", tidy = FALSE, label = "gdp_avgf">>=
fulldata <- list(xx = window(nx, start = c(1985, 1), end = c(2011, 6)),
                 yy = window(ny, start = c(1985, 1), end = c(2011, 2)))
insample <- 1:length(yy)
outsample <- (1:length(fulldata$yy))[-insample]
  
avgf<-average_forecast(list(beta0, betan, um),
                       data = fulldata,
                       insample = insample,
                       outsample = outsample)                                                                      
sqrt(avgf$accuracy$individual$MSE.out.of.sample)       
@ 
We see that the unrestricted MIDAS regression model gives the best out-of-sample RMSE.
%Again the reported RMSE correspond to the ones in \cite{ghysels:2013}.

\subsection{Forecasting realized volatility}

As another demonstration we use the package \pkg{midasr} to forecast the daily realized volatility.  A simple model for forecasting the daily realized volatility was proposed by \cite{corsi2009simple}. The heterogeneous
autoregressive model of realized volatility (HAR-RV) is defined as
\begin{align*}
RV_{t+1}^{(d)}=c+\beta^{(d)}RV_t^{(d)}+\beta^{(w)}RV_{t}^{(w)}+\beta^{(m)}RV_t^{(m)}+w_{t+1},
\end{align*}
where $RV_t$ is the daily realized volatility and $RV_{t}^{(w)}$ and $RV_t^{(m)}$ are weekly and monthly averages:
\begin{align*}
RV_{t}^{(w)}&=\frac{1}{5}\left(RV_{t}^{(d)}+RV_{t-1}^{(d)}+...+RV_{t-4}^{(d)}\right)\\
RV_{t}^{(m)}&=\frac{1}{20}\left(RV_{t}^{(d)}+RV_{t-1}^{(d)}+...+RV_{t-19}^{(d)}\right),
\end{align*}
where we assume that a week has 5 days, and a month has 4 weeks. This model is a special case of a MIDAS regression:
\begin{align*}
  RV_{t+1}^{(d)}=c+\sum_{j=0}^{19}\beta_jRV_{t-j}^{(d)}+w_{t+1},
\end{align*}
where
\begin{align*}
  \beta_{j}=\begin{cases}
    \beta^{(d)}+\frac{1}{5}\beta^{(w)}+\frac{1}{20}\beta^{(m)}, \text{ for } j=0,\\
    \frac{1}{5}\beta^{(w)}+\frac{1}{20}\beta^{(m)}, \text{ for } j=1,..,4,\\
    \frac{1}{20}\beta^{(m)}, \text{ for } j=5,...,19.
    \end{cases}
\end{align*}
The corresponding R code is the following
<<echo=TRUE,cache=FALSE>>=
harstep <- function(p,d,m) {
    if(d!=20) stop("HAR(3)-RV process requires 20 lags")
    out <- rep(0,20)
    out[1] <- p[1]+p[2]/5+p[3]/20
    out[2:5] <- p[2]/5+p[3]/20
    out[6:20] <- p[3]/20
    out
}
@ 

For empirical demonstration we use the realized variance data on stock
indices provided by \cite{oxmandata}.

We estimate the model for the annualized realized volatility of the S\&P500 index, which is based on 5-minute returns data.
<<echo=TRUE,cache=FALSE,label="rv_define">>=
data("rvsp500")
spx2.rvol <- 100*sqrt(252*as.numeric(rvsp500[,"SPX2.rv"]))
mh <- midas_r(rv~mls(rv,1:20,1,harstep),data=list(rv=spx2.rvol),start=list(rv=c(1,1,1)))
summary(mh)
@ 
For comparison we also estimate the model with the normalized exponential Almon weights

<<echo=TRUE,cache=FALSE>>=
mr <- midas_r(rv~mls(rv,1:20,1,nealmon), data=list(rv=spx2.rvol),start=list(rv=c(0,0,0)), 
              weight_gradients = list())
summary(mr)
@ 
We can test which of these restrictions is compatible with the data using the heteroscedasticity and autocorrelation robust weight specification
test \code{hAhr.test}.
<<echo=TRUE,cache=TRUE>>=
hAhr.test(mh)
hAhr.test(mr)
@ 
We can see that the null hypothesis pertaining to the HAR-RV-implied constraints in the MIDAS regression model is rejected at the 0.05 significance level, whereas the null hypothesis that the exponential Almon lag restriction is adequate, cannot be rejected.

Figure \ref{fig:figHAR} illustrates the coefficients of the fitted
MIDAS regressions and the coefficients of U-MIDAS
regression with their corresponding 95\% confidence bounds.

\begin{figure}[tbp]  
<<echo=FALSE,fig.show="hold",fig.height=3.5,cache=TRUE>>=
 plot_midas_coef(mh, title = "")
 lines(0:19,coef(mr, midas = TRUE, term_names = "rv"), col = 3)
@
\caption{Comparison of HAR-RV (blue), Nealmon (green) and U-MIDAS
    (black) models.}
  \label{fig:figHAR}
\end{figure}

For the exponential Almon lag specification we can choose the number
of lags via AIC or BIC. 

<<echo = TRUE, cache = TRUE, results = "markup", tidy = FALSE, label = "rv_select">>=
tb <- expand_weights_lags("nealmon", from = 1, to = c(5, 15),
                          start = list(nealmon = c(0, 0, 0)))
mtb <- midas_r_ic_table(rv ~ mls(rv, 1:20, 1, nealmon),
                        data = list(rv = spx2.rvol), table = list(rv = tb),
                        test = "hAh.test",
                        weight_gradients = list(), show_progress = FALSE)
mtb$candlist <- lapply(mtb$candlist, midas_r, Ofunction = "nls")
mtb$test <- "hAhr.test"
mtb <- midas_r_ic_table(mtb)
@
Here we used two optimization methods to improve the convergence. The function \code{midas_r_ic_table} applies the \code{test} function for each  candidate model. The function \code{hAhr.test} takes a lot of computing time, especialy for models with larger number of lags, so we calculate it only for the second final step, and we restrict the number of lags choose from.  The AIC selects the model with 9 lags:

<<echo=TRUE,cache=TRUE>>=
bm <- modsel(mtb)
@
The HAC robust version of \code{hAh.test} again does not reject the null
hypothesis of the exponential Almon lag specifications.

<<echo=FALSE,cache=FALSE>>=
bm <- midas_r(bm,Ofunction="optim",method="BFGS")
@ 

We can look into the forecast performance of both models, using a
rolling forecast with 1000 observation window. For comparison we also
calculate the forecasts of an unrestricted AR(20) model.

<<echo = TRUE, cache = TRUE, results = "markup", tidy = FALSE, label = "rv_avgf">>=
ar20 <- midas_r(rv ~ mls(rv, 1:20, 1), data = list(rv = spx2.rvol), 
                start = NULL)
forc <- average_forecast(list(ar20, mh, bm),
                             data = list(rv = spx2.rvol),
                             insample = 1:1000, outsample = 1001:1100,
                             type = "rolling", show_progress = FALSE)
forc$accuracy$individual
@
We see that exponential Almon lag model slightly outperforms the
HAR-RV model and both models outperform the AR(20) model.


\section{Final remarks}

Only a part of the available functionality of the discussed functions of the package \pkg{midasr} was discussed. As it is usual in \proglang{R}, much more information on the resulting objects and all the information on the package-specific functions can be retrieved the using generic functions \code{objects} and \code{?}, respectively. Furthermore, in order to save  space, the coding examples provided were almost always presented with minimal accompanying output obtained after running the code. The package page \href{http://mpiktas.github.io/midasr} contains all the codes and complete output together with some additional illustration of the functionality of the package. Other information with a list of the functions and a number of demonstration codes is accessible using the usual \code{??midasr}.

\section{Appendix}

The Figure \ref{fig:fig1} was created using Monte-Carlo simulation. The following DGP was used
\begin{align*}
  y_t&=2+0.1t+\sum_{j = 0}^{16}\beta_jz_{12t-j}+u_t,\text{ }
  z_\tau\sim N(0,\sigma^2),\text{ } u_t\sim N(0,\sigma^2),
\end{align*}
where $z_\tau$ and $u_t$ are independent.

The coefficients $\beta_j$ were chosen to come from the normalized exponential Almon polynomial restriction:
<<eval=FALSE,echo=TRUE,cache=TRUE,results="markup">>=
nealmon(p=c(2,0.5,-0.1),d=17)
@
The data for this DGP was generated for low frequency sample sizes 50, 100, 200, 300, 500, 750 and 1000. For each sample size an  additional out-of-sample data set was generated using a quarter of the size of an in-sample data set. Three MIDAS regression models were estimated using in-sample data set: an unrestricted MIDAS, a restricted one using the correct constraint from the DGP, and the one with an incorrect restriction (non-exponential Almon polynomial). The forecast was calculated using the out-of-sample data-set. The Euclidean distance between the model coefficients and the coefficients of the DGP was recorded together with the mean squared error of the forecast.

This process was repeated 1000 times. The points in the figure are the averages of the replications. The code for generating the data can be found in the help page of a dataset \code{oos_prec} in the package \pkg{midasr}.

\bibliographystyle{jss}
\bibliography{guideR}

\end{document}
